<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ORM on Guilherme Pedrosa</title>
    <link>https://gtpedrosa.github.io/tags/orm/</link>
    <description>Recent content in ORM on Guilherme Pedrosa</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-US</language>
    <lastBuildDate>Sat, 06 Apr 2019 18:56:00 -0300</lastBuildDate>
    
	<atom:link href="https://gtpedrosa.github.io/tags/orm/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Using SQLAlchemy to navigate an existing database</title>
      <link>https://gtpedrosa.github.io/blog/using-sqlalchemy-to-navigate-an-existing-database/</link>
      <pubDate>Sat, 06 Apr 2019 18:56:00 -0300</pubDate>
      
      <guid>https://gtpedrosa.github.io/blog/using-sqlalchemy-to-navigate-an-existing-database/</guid>
      <description>Given the task to interact with an existing database I felt compelled to use the ORM abstraction instead of making queries with raw sql. My aim was to avoid the common pitfalls regarding making text templates for sqlqueries, prone to sql injection exploits, and enhance query composability.
I&amp;rsquo;ve found there are essentialy two ways to approach this task: through reflection or a declarative model. Both approaches are explained in the following sections.</description>
    </item>
    
  </channel>
</rss>